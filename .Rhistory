a1 <- a[!duplicated(a[,"ENSEMBL"]),]
#definir universo para los ENTREZIDs
uni_entrez <- unique(a1$ENTREZID)
#definir universo para los ENTREZIDs
uni_entrez <- unique(a1$ENTREZID[match(uni_ens, a1$ENSEMBL)])
uni_entrez <- uni_entrez[!is.na(uni_entrez)]
uni_entrez <- unique(a1$ENTREZID[match(uni_ens, a1$ENSEMBL)])
uni_entrez <- uni_entrez[!is.na(uni_entrez)]
up_entrez <- unique(a1$ENTREZID[match(up_ens, a1$ENSEMBL)])
up_entrez <- up_entrez[!is.na(up_entrez)]
down_entrez <- unique(a1$ENTREZID[match(down_ens, a1$ENSEMBL)])
down_entrez <- up_entrez[!is.na(down_entrez)]
#carga de librerias
library(clusterProfiler)
library(AnnotationDbi)
library(org.Hs.eg.db)
#carga de librerias
library(clusterProfiler)
library(AnnotationDbi)
library(org.Hs.eg.db)
#carga de datos
tt <- read.csv("dev/ttags.csv", row.names = 1, check.names = T)
tt$ENSEMBL <- rownames(tt)
head(tt)
#definir el universo de genes y los genes up y down regulados
uni_ens <- unique(tt$ENSEMBL)
length(uni_ens)
up_ens <- unique(tt$ENSEMBL[tt$regulation == "Up"])
length(up_ens)
down_ens <- unique(tt$ENSEMBL[tt$regulation == "Down"])
length(down_ens)
#añadir identificadores ENTREZID
a <- AnnotationDbi::select(org.Hs.eg.db,
keys = uni_ens,
keytype = "ENSEMBL",
columns = c("ENTREZID","SYMBOL"))
#Se eliminan las sondas sin ENTREZID
a <- a[!is.na(a[,"ENTREZID"]),]
#se establece mapeo 1:1 para ENSEMBL
a1 <- a[!duplicated(a[,"ENSEMBL"]),]
#definir universo y los id de los up y down regulados para los ENTREZIDs
uni_entrez <- unique(a1$ENTREZID[match(uni_ens, a1$ENSEMBL)])
uni_entrez <- uni_entrez[!is.na(uni_entrez)]
length(uni_entrez)
up_entrez <- unique(a1$ENTREZID[match(up_ens, a1$ENSEMBL)])
up_entrez <- up_entrez[!is.na(up_entrez)]
length(up_entrez)
down_entrez <- unique(a1$ENTREZID[match(down_ens, a1$ENSEMBL)])
down_entrez <- up_entrez[!is.na(down_entrez)]
length(down_entrez)
#1. ORA GO
#genes up regulados
oraUp <- enrichGO(gene = up_ens,
OrgDb = org.Hs.eg.db,
keyType = "ENSEMBL",
ont = "BP",
pAdjustMethod = "BH",
pvalueCutoff = 0.05,
minGSSize = 10,
maxGSSize = 500)
dim(oraUp)
barplot(oraUp)
barplot(oraUp,showCategory = 10)
library(ggplot2)
barplot(oraUp,showCategory = 10)
View(oraUp)
geneList <- tt$logFC
names(geneList) <- tt$ENSEMBL
geneList <- sort(geneList, decreasing = T)
head(geneList)
tail(geneList)
gseaGO <- gseGO(geneList = geneList,
ont = "BP",
OrgDb = org.Hs.eg.db,
keyType = "ENSEMBL",
verbose = T,
minGSSize = 10,
maxGSSize = 500,
pAdjustMethod = "BH",
pvalueCutoff = 1)
dim(gseaGO)
dotplot(gseaGO, showCategory = 10) + ggtitle("GSEA")
gsea_go <- gseGO(
geneList      = geneList_ens,
OrgDb         = OrgDb,
keyType       = "ENSEMBL",
ont           = go_ont,
minGSSize     = minGS,
maxGSSize     = maxGS,
pAdjustMethod = "BH",
pvalueCutoff  = 0.25,
verbose       = TRUE
)
gseaGO <- gseGO(geneList = geneList,
ont = "BP",
OrgDb = org.Hs.eg.db,
keyType = "ENSEMBL",
verbose = T,
minGSSize = 10,
maxGSSize = 500,
pAdjustMethod = "BH",
pvalueCutoff = 0.25)
dim(gseaGO)
dotplot(gseaGO, showCategory = 10) + ggtitle("GSEA")
#4. GSEA KEGG
geneList_kegg <- tt$logFC
names(geneList_kegg) <- a1$ENTREZID
geneList_kegg <- sort(geneList_kegg, decreasing = T)
head(geneList_kegg)
is.na(geneList_kegg)
table(is.na(geneList_kegg))
names(geneList_kegg) <- a1$ENTREZID[match(tt$ENSEMBL, a1$ENSEMBL)]
table(is.na(geneList_kegg))
head(geneList_kegg)
tail(geneList_kegg)
gseaKEGG <- gseKEGG(geneList = geneList_kegg,
organism = "hsa",
keyType = "ncbi-geneid",
pvalueCutoff = 0.05,
verbose = T)
table(is.na(names(geneList_kegg)))
geneList_kegg <- geneList_kegg[!is.na(names(geneList_kegg))]
table(is.na(names(geneList_kegg)))
gseaKEGG <- gseKEGG(geneList = geneList_kegg,
organism = "hsa",
keyType = "ncbi-geneid",
pvalueCutoff = 0.05,
verbose = T)
dim(gseaKEGG@result)
runApp()
library(shiny)
library(shinydashboard)
library(clusterProfiler)
library(AnnotationDbi)
library(org.Hs.eg.db)
library(org.Mm.eg.db)
library(ggplot2)
library(DT)
runApp()
#modulo de enriquecimiento funcional
#library(shiny)
#library(shinydashboard)
#library(clusterProfiler)
#library(AnnotationDbi)
#library(org.Hs.eg.db)
#library(org.Mm.eg.db)
#library(ggplot2)
#library(DT)
library(enrichplot)
runApp()
runApp()
runApp()
setwd("C:/Users/melia/Bioinformática_l/2n/TFM_l/Datos/EXP2/metabolites")
x <- read.csv("roots.csv", header = T)
View(x)
ncols(x)
dim(x)
y <- read.csv()
y <- read.csv("shoots.csv", header = T)
setwd("C:/Users/melia/Bioinformática_l/2n/TFM_l/R")
library(shiny)
library(shinydashboard)
library(clusterProfiler)
library(AnnotationDbi)
library(org.Hs.eg.db)
library(org.Mm.eg.db)
library(ggplot2)
library(DT)
library(enrichplot)
library(plotly)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
library(shiny)
library(shinydashboard)
library(edgeR)
library(PCAtools)
library(ggplot2)
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
bslib::bs_theme_preview()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
library(shiny)
library(shinydashboard)
library(shinythemes)
library(shinyWidgets)
library(shinycssloaders)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?shinyWidgets::downloadBttn()
library(shiny)
library(shinydashboard)
library(shinyWidgets)
library(shinythemes)
library(edgeR)
library(ggplot2)
library(plotly)
library(DT)
library(PCAtools)
library(dplyr)
library(EnhancedVolcano)
library(clusterProfiler)
library(AnnotationDbi)
library(org.Hs.eg.db)
library(org.Mm.eg.db)
library(enrichplot)
runApp()
library(shinycssloaders)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
library(shiny); runApp('v2_app.R')
runApp()
runApp('v2_app.R')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp('v2_app.R')
runApp('v2_app.R')
runApp('v2_app.R')
runApp('v2_app.R')
runApp()
runApp('v2_app.R')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
setwd("C:/Users/melia/shinyDEG_dev/dev")
# geo_series_matrix_to_metadata.R
# Convierte GSE*_series_matrix.txt(.gz) a metadata.csv (muestras x columnas)
# Base R only (sin dependencias)
read_series_matrix <- function(path) {
# Lee .txt o .txt.gz
con <- if (grepl("\\.gz$", path, ignore.case = TRUE)) gzfile(path, "rt") else file(path, "rt")
on.exit(close(con), add = TRUE)
readLines(con, warn = FALSE)
}
trim_ws <- function(x) gsub("^\\s+|\\s+$", "", x)
safe_make_names <- function(x) {
# nombres de columna limpios y únicos
x <- trim_ws(x)
x <- gsub("[^A-Za-z0-9_]+", "_", x)
x <- gsub("_+", "_", x)
x <- gsub("^_|_$", "", x)
x <- tolower(x)
make.unique(ifelse(x == "", "x", x), sep = "_")
}
# Parsea "key: value" dentro de characteristics
parse_kv <- function(x) {
x <- trim_ws(x)
# Algunos vienen como "key: value", otros como "key=value", otros sin separador
if (grepl(":", x, fixed = TRUE)) {
parts <- strsplit(x, ":", fixed = TRUE)[[1]]
key <- trim_ws(parts[1])
val <- trim_ws(paste(parts[-1], collapse = ":"))
return(list(key = key, val = val))
}
if (grepl("=", x, fixed = TRUE)) {
parts <- strsplit(x, "=", fixed = TRUE)[[1]]
key <- trim_ws(parts[1])
val <- trim_ws(paste(parts[-1], collapse = "="))
return(list(key = key, val = val))
}
# sin clave explícita
return(list(key = NA_character_, val = x))
}
series_matrix_to_metadata <- function(series_matrix_path,
out_csv = "metadata.csv",
prefer_condition_keys = c("condition", "group", "treatment", "phenotype", "status"),
verbose = TRUE) {
raw <- read_series_matrix(series_matrix_path)
# Nos quedamos solo con líneas !Sample_ (evita el resto del fichero)
sample_lines <- raw[grepl("^!Sample_", raw)]
if (length(sample_lines) == 0) {
stop("No se encontraron líneas '!Sample_' en el archivo. ¿Seguro que es un series_matrix?")
}
# Tab separado por \t: primera columna es la etiqueta, resto son valores por GSM
tab <- strsplit(sample_lines, "\t", fixed = TRUE)
max_len <- max(vapply(tab, length, integer(1)))
tab <- lapply(tab, function(x) { length(x) <- max_len; x })
mat <- do.call(rbind, tab)
# Etiquetas de campo (col 1)
field_raw <- mat[, 1]
values <- mat[, -1, drop = FALSE]
# Los GSM suelen estar en !Sample_geo_accession
# Si está, úsalo como sample_id; si no, usa nombres de columna (que suelen ser GSM)
# values columnas = muestras
# OJO: algunas series matrix incluyen comillas o espacios
values <- apply(values, 2, trim_ws)
values[is.na(values)] <- ""
# Construimos un data.frame base: filas = muestras, columnas = campos
# field names sin el prefijo "!Sample_"
fields <- gsub("^!Sample_", "", field_raw)
fields <- safe_make_names(fields)
df0 <- as.data.frame(t(values), stringsAsFactors = FALSE)
colnames(df0) <- fields
# Determina sample_id
if ("geo_accession" %in% colnames(df0)) {
df0$sample_id <- df0$geo_accession
} else {
# fallback: usa colnames del values (a veces no vienen), o crea ids
df0$sample_id <- rownames(df0)
if (all(is.na(df0$sample_id)) || all(df0$sample_id == "")) {
df0$sample_id <- paste0("sample_", seq_len(nrow(df0)))
}
}
# Expandir characteristics_ch1 (puede haber varias filas en series matrix,
# pero aquí suelen haberse "aplastado" si existían múltiples: en series_matrix
# cada fila !Sample_characteristics_ch1 aparece repetida. Al transponer,
# se generan columnas duplicadas como characteristics_ch1, characteristics_ch1_1, etc.
char_cols <- grep("^characteristics_ch1", colnames(df0), value = TRUE)
expanded <- list()
if (length(char_cols) > 0) {
# Para cada columna de characteristics, parsea cada celda "key: val"
for (cc in char_cols) {
kvs <- lapply(df0[[cc]], parse_kv)
keys <- vapply(kvs, function(z) z$key, character(1))
vals <- vapply(kvs, function(z) z$val, character(1))
# Si hay keys NA, las ignoramos (o las metemos como free_text)
ok <- !is.na(keys) & keys != ""
if (any(ok)) {
# normaliza nombres de key y añade columna
key_norm <- safe_make_names(keys[ok])
for (k in unique(key_norm)) {
idx <- ok & safe_make_names(keys) == k
colname <- k
# Si ya existe, lo combinamos con "; "
if (!is.null(expanded[[colname]])) {
expanded[[colname]][idx] <- paste(expanded[[colname]][idx], vals[idx], sep = "; ")
} else {
expanded[[colname]] <- rep(NA_character_, nrow(df0))
expanded[[colname]][idx] <- vals[idx]
}
}
} else {
# todo sin key -> lo guardamos como nota
note_col <- "characteristics_free_text"
if (is.null(expanded[[note_col]])) expanded[[note_col]] <- rep(NA_character_, nrow(df0))
expanded[[note_col]] <- ifelse(
is.na(expanded[[note_col]]) | expanded[[note_col]] == "",
vals,
paste(expanded[[note_col]], vals, sep = "; ")
)
}
}
}
df_exp <- if (length(expanded) > 0) as.data.frame(expanded, stringsAsFactors = FALSE) else NULL
# Metadata final: sample_id primero, luego columnas expandidas, luego el resto “útil”
# Quitamos las columnas raw de characteristics (redundan)
df_keep <- df0
if (length(char_cols) > 0) df_keep[char_cols] <- list(NULL)
# Junta
out <- df_keep
if (!is.null(df_exp)) {
# Evita colisiones: si una expandida existe ya en df_keep, la renombra
overlap <- intersect(colnames(df_exp), colnames(out))
if (length(overlap) > 0) {
colnames(df_exp)[match(overlap, colnames(df_exp))] <- paste0(overlap, "_char")
}
out <- cbind(out, df_exp)
}
# Reordenar: sample_id primero
out <- out[, c("sample_id", setdiff(colnames(out), "sample_id")), drop = FALSE]
# Intento de crear una columna "condition" si existe alguna key típica
# (sin forzar si ya existe)
if (!("condition" %in% colnames(out))) {
for (k in prefer_condition_keys) {
k2 <- safe_make_names(k)
if (k2 %in% colnames(out)) {
out$condition <- out[[k2]]
break
}
}
}
# Limpieza ligera: convierte "" a NA
out[out == ""] <- NA_character_
# Guarda
write.csv(out, out_csv, row.names = FALSE, na = "")
if (verbose) {
message("OK: creado ", out_csv)
message("Muestras: ", nrow(out), " | Columnas: ", ncol(out))
message("Columnas principales: ", paste(head(colnames(out), 12), collapse = ", "),
if (ncol(out) > 12) " ..." else "")
if ("condition" %in% colnames(out)) message("Detectada columna condition.")
}
invisible(out)
}
# ---- USO (ejemplo) ----
meta <- series_matrix_to_metadata("GSE284157_series_matrix.txt", "metadata_r.csv")
shiny::runApp()
runApp()
setwd("C:/Users/melia/shinyDEG_dev")
shiny::runApp()
runApp()
